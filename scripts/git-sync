#!/usr/bin/env bash
#
# git-sync [--push] [<branch>]
# Sync your feature/* or bugfix/* with develop,
# or hotfix/* with main, using rebase with autostash.
# Optionally push/create remote branch after.
#
set -euo pipefail

error() { printf 'Error: %s\n' "$1" >&2; exit 1; }
usage() {
  cat <<EOF
Usage: $(basename "$0") [--push] [<branch>]
  --push      after syncing, push (and create) remote branch
  <branch>    branch to sync; defaults to current branch
EOF
  exit 1
}

get_branch_name() {
  if [ $# -gt 1 ]; then
    usage
  elif [ $# -eq 1 ]; then
    echo "$1"
  else
    git rev-parse --abbrev-ref HEAD 2>/dev/null \
      || error "⚠️  Not a git repo or cannot detect current branch."
  fi
}

detect_base() {
  [[ "${BRANCH%%/*}" == hotfix ]] && echo main || echo develop
}

validate_prefix() {
  [[ "${BRANCH}" =~ ^(feature|bugfix|hotfix)/.+$ ]] \
    || error "⚠️  Branch name must start with feature/, bugfix/ or hotfix/."
}

fetch_with_prune() {
  echo "→ [STEP 1/2] Fetch remote and prune"
  git fetch --prune origin
}

sync_rebase() {
  echo "→ [STEP 2/2] Rebase '${BRANCH}' onto 'origin/${BASE}' with auto-stash"
  if ! git rebase "origin/${BASE}" --autostash; then
    error "⚠️  Rebase failed. Resolve conflicts, and run 'git rebase --continue' or 'git rebase --abort'."
  fi
}

push_remote() {
  echo "→ [PUSH MODE] Ensure remote branch 'origin/${BRANCH}' exists"
  if git show-ref --verify --quiet "refs/remotes/origin/${BRANCH}"; then
    echo "↳ Remote exists → push commits"
    git push origin "${BRANCH}" || error "⚠️  Push failed."
  else
    create_remote_branch
  fi
}

create_remote_branch() {
  echo "↳ Create remote branch 'origin/${BRANCH}' and push commits"
  git push -u origin "HEAD:${BRANCH}" \
    || error "⚠️  Failed to create remote branch."
}

# sync_base_branch() {
#   echo "→ [STEP 3/5] Sync base '${BASE}'"
#   git checkout "${BASE}"
#   git pull --ff-only origin "${BASE}"
# }
# merge_base_into() {
#   echo "→ [STEP 4/5] Rebase '${BRANCH}' onto '${BASE}'"
#   git checkout "${BRANCH}"
#   git rebase "${BASE}" --autostash || {
#     error "↳ Rebase failed. Resolve conflicts, then 'git rebase --continue'."
#   }
# }
# Not necessary with rebase --autostash
# do_stash() {
#   local MSG="git-sync auto-stash on $(date '+%Y-%m-%d %H:%M:%S')"
#   echo "→ [STEP 2/5] Stash uncommitted changes: ${MSG}"

#   local output
#   output=$(git stash push --keep-index --include-untracked -m "${MSG}")
#   if ! grep -q "↳ No local changes to save" <<< "${output}"; then
#     STASHED=true
#     LAST_STASH_REF="stash@{0}"
#   else
#     STASHED=false
#   fi
# }
# do_pop() {
#   local trap="${1:-false}"

#   if [[ "${STASHED:-false}" != "true" ]]; then
#     [[ "$trap" != "true" ]] && echo "↳ No auto-stash to restore."
#     return
#   fi

#   if [[ "$trap" != "true" ]]; then
#     echo "→ [STEP 5/5] Restore stash"
#   else
#     echo "⚠️  Error occurred in sync. Restore stash"
#   fi

#   git stash pop --index "${LAST_STASH_REF}" \
#     || echo "⚠️  Could not pop ${LAST_STASH_REF}"
# }

main() {
  BRANCH=$(get_branch_name "$@")
  BASE=$(detect_base)
  echo "→ Starting sync for '${BRANCH}' against '${BASE}'"

  local do_push=false
  if [[ "${BRANCH}" == "--push" ]]; then
    do_push=true
    shift
  fi

  validate_prefix
  fetch_with_prune
  sync_rebase

  #do_stash
  # trap 'do_pop true; exit 1' ERR INT
  # sync_base_branch
  # merge_base_into
  # trap - ERR INT
  #do_pop

  if $do_push; then
    push_remote
    echo "✔ Local branch '${BRANCH}' synced with '${BASE}' and pushed to 'origin/${BRANCH}'"
  else
    echo "✔ Local branch '${BRANCH}' synced with '${BASE}'"
  fi
}

main "$@"
