#!/usr/bin/env bash
#
# git-sync [<branch>]
# Sync your feature/* or bugfix/* with develop,
# or hotfix/* with main.
#

set -euo pipefail

error() {
  printf 'Error: %s\n' "$1" >&2
  exit 1
}

usage() {
  cat <<EOF
Usage: $(basename "$0") [<branch>]
  If no <branch> given, uses the current branch.
  Branch must start with feature/, bugfix/ or hotfix/.
EOF
  exit 1
}

get_branch_name() {
  if [ $# -gt 1 ]; then
    usage
  elif [ $# -eq 1 ]; then
    echo "$1"
  else
    git rev-parse --abbrev-ref HEAD 2>/dev/null \
      || error "Not a git repo or cannot detect current branch."
  fi
}

detect_base() {
  [[ "${1%%/*}" == hotfix ]] && echo main || echo develop
}

validate_prefix() {
  [[ "$1" =~ ^(feature|bugfix|hotfix)/.+$ ]] \
    || error "Branch name must start with feature/, bugfix/ or hotfix/."
}

fetch_and_prune() {
  echo "→ [STEP 1/5] Fetch remote and prune"
  git fetch --prune origin
}

 do_stash() {
  local MSG="git-sync auto-stash on $(date '+%Y-%m-%d %H:%M:%S')"
  echo "→ [STEP 2/5] Stash uncommitted changes: ${MSG}"

  local output
  output=$(git stash push --keep-index --include-untracked -m "${MSG}")

  if ! grep -q "No local changes to save" <<< "$output"; then
    STASHED=true
    LAST_STASH_REF="stash@{0}"
  else
    STASHED=false
  fi
}

sync_branch() {
  echo "→ [STEP 3/5] Sync base '$(detect_base "$1")'"
  git checkout "$(detect_base "$1")"
  git pull --ff-only origin "$(detect_base "$1")"
}

merge_base_into() {
  echo "→ [STEP 4/5] Merge into '$1'"
  git checkout "$2"
  git merge --no-ff "$1"
}

do_pop() {
  local trap="${1:-false}"

  if [[ "${STASHED:-false}" != "true" ]]; then
    [[ "$trap" != "true" ]] && echo "→ No auto-stash to restore."
    return
  fi

  if [[ "$trap" != "true" ]]; then
    echo "→ [STEP 5/5] Restore stash"
  else
    echo "⚠️  Error occurred in sync. Restore stash"
  fi

  git stash pop --index "${LAST_STASH_REF}" \
    || echo "⚠️  Could not pop ${LAST_STASH_REF}"
}

push_remote() {
  echo "→ [PUSH MODE] Check remote branch 'origin/${BRANCH}'"
  if git show-ref --verify --quiet "refs/remotes/origin/${BRANCH}"; then
    echo "→ [PUSH MODE] Push '${BRANCH}' to 'origin/${BRANCH}'"
    git push origin "${BRANCH}" || error "Push failed."
  else
    create_remote_branch
  fi
}

create_remote_branch() {
  echo "→ [PUSH MODE] Create remote branch 'origin/${BRANCH}' and push"
  git push -u origin "HEAD:${BRANCH}" \
    || error "Failed to create remote branch."
}

main() {
  local branch base
  branch=$(get_branch_name "$@")
  base=$(detect_base "$branch")
  echo "→ Starting sync for branch '${branch}' with '${base}'"

  local do_push=false
  if [[ $# -gt 0 && "$1" == "--push" ]]; then
    do_push=true
    shift
  fi

  validate_prefix "$branch"
  fetch_and_prune
  do_stash

  trap 'do_pop true; exit 1' ERR INT
  sync_branch "$base"
  merge_base_into "$base" "$branch"
  trap - ERR

  do_pop

  local done_msg="✔ Local branch '${branch}' synced with '${base}'"

  if $do_push; then
    push_remote "$branch"
    done_msg+=" and pushed to 'origin/${branch}'"
  fi

  echo "$done_msg"
}

main "$@"
